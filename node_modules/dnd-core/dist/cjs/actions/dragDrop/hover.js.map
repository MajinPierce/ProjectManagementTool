{"version":3,"sources":["../../../../src/actions/dragDrop/hover.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport type {\n\tAction,\n\tDragDropManager,\n\tHoverPayload,\n\tHoverOptions,\n\tDragDropMonitor,\n\tHandlerRegistry,\n\tIdentifier,\n} from '../../interfaces.js'\nimport { matchesType } from '../../utils/matchesType.js'\nimport { HOVER } from './types.js'\n\nexport function createHover(manager: DragDropManager) {\n\treturn function hover(\n\t\ttargetIdsArg: string[],\n\t\t{ clientOffset }: HoverOptions = {},\n\t): Action<HoverPayload> {\n\t\tverifyTargetIdsIsArray(targetIdsArg)\n\t\tconst targetIds = targetIdsArg.slice(0)\n\t\tconst monitor = manager.getMonitor()\n\t\tconst registry = manager.getRegistry()\n\t\tcheckInvariants(targetIds, monitor, registry)\n\t\tconst draggedItemType = monitor.getItemType()\n\t\tremoveNonMatchingTargetIds(targetIds, registry, draggedItemType)\n\t\thoverAllTargets(targetIds, monitor, registry)\n\n\t\treturn {\n\t\t\ttype: HOVER,\n\t\t\tpayload: {\n\t\t\t\ttargetIds,\n\t\t\t\tclientOffset: clientOffset || null,\n\t\t\t},\n\t\t}\n\t}\n}\n\nfunction verifyTargetIdsIsArray(targetIdsArg: string[]) {\n\tinvariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.')\n}\n\nfunction checkInvariants(\n\ttargetIds: string[],\n\tmonitor: DragDropMonitor,\n\tregistry: HandlerRegistry,\n) {\n\tinvariant(monitor.isDragging(), 'Cannot call hover while not dragging.')\n\tinvariant(!monitor.didDrop(), 'Cannot call hover after drop.')\n\tfor (let i = 0; i < targetIds.length; i++) {\n\t\tconst targetId = targetIds[i] as string\n\t\tinvariant(\n\t\t\ttargetIds.lastIndexOf(targetId) === i,\n\t\t\t'Expected targetIds to be unique in the passed array.',\n\t\t)\n\n\t\tconst target = registry.getTarget(targetId)\n\t\tinvariant(target, 'Expected targetIds to be registered.')\n\t}\n}\n\nfunction removeNonMatchingTargetIds(\n\ttargetIds: string[],\n\tregistry: HandlerRegistry,\n\tdraggedItemType: Identifier | null,\n) {\n\t// Remove those targetIds that don't match the targetType.  This\n\t// fixes shallow isOver which would only be non-shallow because of\n\t// non-matching targets.\n\tfor (let i = targetIds.length - 1; i >= 0; i--) {\n\t\tconst targetId = targetIds[i] as string\n\t\tconst targetType = registry.getTargetType(targetId)\n\t\tif (!matchesType(targetType, draggedItemType)) {\n\t\t\ttargetIds.splice(i, 1)\n\t\t}\n\t}\n}\n\nfunction hoverAllTargets(\n\ttargetIds: string[],\n\tmonitor: DragDropMonitor,\n\tregistry: HandlerRegistry,\n) {\n\t// Finally call hover on all matching targets.\n\ttargetIds.forEach(function (targetId) {\n\t\tconst target = registry.getTarget(targetId)\n\t\ttarget.hover(monitor, targetId)\n\t})\n}\n"],"names":["createHover","manager","hover","targetIdsArg","clientOffset","verifyTargetIdsIsArray","targetIds","slice","monitor","getMonitor","registry","getRegistry","checkInvariants","draggedItemType","getItemType","removeNonMatchingTargetIds","hoverAllTargets","type","HOVER","payload","invariant","Array","isArray","isDragging","didDrop","i","length","targetId","lastIndexOf","target","getTarget","targetType","getTargetType","matchesType","splice","forEach"],"mappings":"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"}