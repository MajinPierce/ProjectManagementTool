{"version":3,"sources":["../../../src/internals/wrapConnectorHooks.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport { cloneElement, isValidElement, ReactElement } from 'react'\n\nfunction throwIfCompositeComponentElement(element: ReactElement<any>) {\n\t// Custom components can no longer be wrapped directly in React DnD 2.0\n\t// so that we don't need to depend on findDOMNode() from react-dom.\n\tif (typeof element.type === 'string') {\n\t\treturn\n\t}\n\n\tconst displayName =\n\t\t(element.type as any).displayName || element.type.name || 'the component'\n\n\tthrow new Error(\n\t\t'Only native element nodes can now be passed to React DnD connectors.' +\n\t\t\t`You can either wrap ${displayName} into a <div>, or turn it into a ` +\n\t\t\t'drag source or a drop target itself.',\n\t)\n}\n\nfunction wrapHookToRecognizeElement(hook: (node: any, options: any) => void) {\n\treturn (elementOrNode = null, options = null) => {\n\t\t// When passed a node, call the hook straight away.\n\t\tif (!isValidElement(elementOrNode)) {\n\t\t\tconst node = elementOrNode\n\t\t\thook(node, options)\n\t\t\t// return the node so it can be chained (e.g. when within callback refs\n\t\t\t// <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\t\t\treturn node\n\t\t}\n\n\t\t// If passed a ReactElement, clone it and attach this function as a ref.\n\t\t// This helps us achieve a neat API where user doesn't even know that refs\n\t\t// are being used under the hood.\n\t\tconst element: ReactElement | null = elementOrNode\n\t\tthrowIfCompositeComponentElement(element as any)\n\n\t\t// When no options are passed, use the hook directly\n\t\tconst ref = options ? (node: Element) => hook(node, options) : hook\n\t\treturn cloneWithRef(element, ref)\n\t}\n}\n\nexport function wrapConnectorHooks(hooks: any) {\n\tconst wrappedHooks: any = {}\n\n\tObject.keys(hooks).forEach((key) => {\n\t\tconst hook = hooks[key]\n\n\t\t// ref objects should be passed straight through without wrapping\n\t\tif (key.endsWith('Ref')) {\n\t\t\twrappedHooks[key] = hooks[key]\n\t\t} else {\n\t\t\tconst wrappedHook = wrapHookToRecognizeElement(hook)\n\t\t\twrappedHooks[key] = () => wrappedHook\n\t\t}\n\t})\n\n\treturn wrappedHooks\n}\n\nfunction setRef(ref: any, node: any) {\n\tif (typeof ref === 'function') {\n\t\tref(node)\n\t} else {\n\t\tref.current = node\n\t}\n}\n\nfunction cloneWithRef(element: any, newRef: any): ReactElement<any> {\n\tconst previousRef = element.ref\n\tinvariant(\n\t\ttypeof previousRef !== 'string',\n\t\t'Cannot connect React DnD to an element with an existing string ref. ' +\n\t\t\t'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' +\n\t\t\t'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs',\n\t)\n\n\tif (!previousRef) {\n\t\t// When there is no ref on the element, use the new ref directly\n\t\treturn cloneElement(element, {\n\t\t\tref: newRef,\n\t\t})\n\t} else {\n\t\treturn cloneElement(element, {\n\t\t\tref: (node: any) => {\n\t\t\t\tsetRef(previousRef, node)\n\t\t\t\tsetRef(newRef, node)\n\t\t\t},\n\t\t})\n\t}\n}\n"],"names":["invariant","cloneElement","isValidElement","throwIfCompositeComponentElement","element","type","displayName","name","Error","wrapHookToRecognizeElement","hook","elementOrNode","options","node","ref","cloneWithRef","wrapConnectorHooks","hooks","wrappedHooks","Object","keys","forEach","key","endsWith","wrappedHook","setRef","current","newRef","previousRef"],"mappings":"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"}